/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ogre;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.image.BufferedImage;
import static java.awt.image.ImageObserver.HEIGHT;
import static java.awt.image.ImageObserver.WIDTH;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import java.util.LinkedList;
import java.util.Enumeration;

/**
 *
 * @author Skot
 */
public class GamePanel extends javax.swing.JPanel implements Runnable, KeyListener, MouseListener, MouseWheelListener {

    //CONSTANTS
    private final int SLEEP_INTERVAL = 10;
    private static final int PANEL_WIDTH = 1124;
    private static final int PANEL_HEIGHT = 600;
    private static final int BLOCK_SIZE = 30; //in pixels
    
    //VARIABLES
    private Thread animator;
    private volatile boolean running = false;    
    private volatile boolean gameOver = false;
    
    private Graphics dbg;
    private Image dbImage = null;
    
    java.util.Random rando;
    
    BufferedImage picture;
    
    LinkedList<java.awt.Polygon> clickMap;
    java.awt.Polygon selectedHex;
    
    public GamePanel() 
    {
        initComponents();
        
        setFocusable(true);
        requestFocus();
        //readyForTermination();
        
        addKeyListener(this);
        addMouseListener(this);
        addMouseWheelListener(this);
         
        rando = new java.util.Random();
        
        setBackground(Color.RED);
        setPreferredSize(new Dimension(PANEL_WIDTH,PANEL_HEIGHT));
        
        clickMap = new LinkedList();
        clickMap.clear();
        
        selectedHex = null;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    
    //*** ADD NOTIFY
    //A mystery
    @Override
    public void addNotify()
    {
        //Creates the peer, starts the game
        super.addNotify();
        startGame();
    }
    
    @Override    
    protected void finalize() throws Throwable
    {
        super.finalize();
        if (animator != null)
        {
            running = false;
        }
    }
   
    //*** START GAME
    private void startGame()
    {
        if ((animator == null) || (running == false))
        {
           animator = new Thread(this);
           animator.start();
        }
    }
    
    
     
    //*** STOP GAME
    public void stopGame()
    {
        running = false;
    }
    
    
    //*** RUN
    //Update, render, sleep
    @Override
    public void run()
    {
        running = true;
        while (running == true)
        {
            gameUpdate();
            gameRender();
            paintScreen();
            
            //Nighty-night
            try
            {
                Thread.sleep(SLEEP_INTERVAL);
            }
            
            catch (InterruptedException ex)
            {
                
            }
        }
        
        System.exit(0);
    }

    
    //*** GAME UPDATE
    private void gameUpdate()
    {
        if (gameOver == false)
        {
            
        }
    }//gameover != true
    
    
    //GAME RENDER
    private void gameRender()
    {
        if (dbImage == null)
        {
            dbImage = createImage(PANEL_WIDTH, PANEL_HEIGHT);
        }
        
        if (dbImage == null)
        {
            System.out.println("dbImage is null, damnit");
            return;
        }
        
        else
        {
            dbg = dbImage.getGraphics();
        }
        
        //Clear background
        dbg.setColor(java.awt.Color.WHITE);
        dbg.fillRect(0,0,PANEL_WIDTH,PANEL_HEIGHT);
        dbg.drawImage(picture, WIDTH, HEIGHT, this);
        
        //AffineTransform transform;
        //BufferedImage tmp = null;
        
        //draw hexes
        int hexSide = 28;
        
        int x_origin = 10;
        int y_origin = 10;
        int x = x_origin;
        int y = y_origin;
        
        
        //Draw hex field
        for (int i = 1; i < 22; i++)
        {
           for (int j = 1; j < 16; j++)
           {
               java.awt.Polygon p = new java.awt.Polygon();
               p.reset();
               
               p.addPoint(x +(hexSide/2), y);
               p.addPoint(x+(hexSide/2) + hexSide, y);
               p.addPoint(x + 2*hexSide, (int)(.8660* hexSide + y));
               p.addPoint(x+(hexSide/2) + hexSide, (int)(.8660 * 2 * hexSide + y));
               p.addPoint(x+(hexSide/2),(int)(.8660*2*hexSide + y));
               p.addPoint(x,y+(int)(.8660 * hexSide));
               
               dbg.setColor(Color.BLACK);
               dbg.drawPolygon(p);
               clickMap.add(p);
               
               y = y + (int)(2 * .8660 * hexSide);
           }
        
            x = x + (hexSide/2) + hexSide;
            
            if ((i%2) > 0)
               y = y_origin + (int)(.8660 * hexSide); 
            else
                y = y_origin;
            
        }    
        
        //Highlight a hex
        if(selectedHex != null)
        {
            dbg.setColor(Color.RED);
            dbg.fillPolygon(selectedHex);
            dbg.drawPolygon(selectedHex);
        }
        
        //DRAW 
        if (gameOver == true)
        {
            gameOverMsg(dbg);
        }
    }
    
    //PAINT COMPONENT
    @Override
    public void paintComponent(Graphics g)
    {
        if (dbImage != null)
        {
           g.drawImage(dbImage, 0, 0, null); 
        }
    }

    
    //PAINT SCREEN
    //active rendering to the screen
    private void paintScreen()
    {
        Graphics g;
        
        try 
        {
            g = this.getGraphics();
            if ((g != null) && (dbImage != null))
            {
                g.drawImage(dbImage, 0, 0, null);
            }
            java.awt.Toolkit.getDefaultToolkit().sync();
        }
        
        catch (Exception e)
        {
            System.out.println("Graphics context error:" + e);
        }
    }
    
    //GAME OVER MSG
    private void gameOverMsg(Graphics g)
    {
        //g.drawString(msg,x,y);
    }
    
    
                  
    
    
    public void keyPressed(KeyEvent e)
    {
        switch (e.getKeyChar())
        {
            
            default:
                break;
        }
    }
    
    public void keyReleased(KeyEvent e)
    {
        
    }
    
    public void keyTyped(KeyEvent e)
    {   
        
        switch (e.getKeyChar())
        {
            
            default:
                break;
               
        }       

    }
   
    //MOUSE ROUTINES
    
    //MOUSE WHEEL MOVED
    //Zooms in and out
    @Override
    public void mouseWheelMoved(MouseWheelEvent e)
    {
        
        System.out.println(e.getWheelRotation());
        
        if (e.getWheelRotation() >= 0)
        {
            
        }
        
        else
        {
           
        }
    }
    
    
    @Override
    public void mouseEntered(MouseEvent e)
    {
        
    }
    
    @Override
    public void mouseExited(MouseEvent e)
    {
        
    }
    
    @Override
    public void mousePressed(MouseEvent e)
    {
        
    }
   
    //MOUSE CLICKED
    
    @Override
    public void mouseClicked(MouseEvent e)
    {   
        //*LEFT* CLICK
        if (e.getButton() == MouseEvent.BUTTON1)
        {
            //If no hex was selected, select it
            if (selectedHex == null)
            {    
                java.util.Iterator<java.awt.Polygon> polys = clickMap.listIterator();
                java.awt.Polygon p = null;

                while (polys.hasNext())
                {
                    p = polys.next();

                    if (p.contains(e.getX(), e.getY()))
                    {
                        selectedHex = p;
                        return;
                    }                
                }
            }
            
            
            else
                selectedHex = null;
        }//mouse
        
        
        //*RIGHT* CLICK
        if (e.getButton() == MouseEvent.BUTTON3)
        {
           selectedHex = null;
        }//if RIGHT BUTTON
    }  
    
    
    @Override
    public void mouseReleased(MouseEvent e)
    {
        
    }
    
    
     //LOAD IMAGE
    protected void load_image(String image_file, BufferedImage pic)
    {
        InputStream fin = null;
 
        if ((!image_file.matches("none")))
        {
            fin = getClass().getResourceAsStream("resources/images/" + image_file);
            
            try 
            {
                pic = ImageIO.read(fin);
                picture = pic;
            }
            catch (IOException e) 
            {
                System.out.println(image_file + ": NAW, DAWG");
            }
            
            if (fin != null)
            {
                try
                {
                    fin.close();
                }
                catch (IOException e)
                {
                    System.out.println("ERROR: Can't close it fin");
                }
            }
        }
        
        else
            picture = null;
    }
    
    
}
