/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ogre;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.image.BufferedImage;
import static java.awt.image.ImageObserver.HEIGHT;
import static java.awt.image.ImageObserver.WIDTH;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import java.util.LinkedList;
import java.util.Enumeration;

/**
 *
 * @author Skot
 */
public class GamePanel extends javax.swing.JPanel implements Runnable, KeyListener, MouseListener, MouseWheelListener {

    //CONSTANTS
    private final int SLEEP_INTERVAL = 10;
    private static final int PANEL_WIDTH = 800;
    private static final int PANEL_HEIGHT = 600;
    //private static final int BLOCK_SIZE = 30; //in pixels
    
    //for the hex map
    HexMap hexMap;
    public int hexSide = 64;
    public final int HEX_ROWS = 21;
    public final int HEX_COLS = 15;
    public final int BIG_DB_WIDTH = 2500;
    public final int BIG_DB_HEIGHT = 2000; 

    public final int VIEW_WINDOW_WIDTH = 800;
    public final int VIEW_WINDOW_HEIGHT = 600;
    
    
    //VARIABLES
    private Thread animator;
    private volatile boolean running = false;    
    private volatile boolean gameOver = false;
    
    private Graphics dbg;
    private Image dbImage = null;
    
    java.util.Random rando;

    java.awt.Polygon selectedHex;
    
    //User-interaction flags
    boolean scrolling = false;
    int scrollingX, scrollingY;     //stores prior position of mouse to compare
    int currentWindowX, currentWindowY;   //stores current position of the upper corner of the view window
    float zoomFactor = 1.0F;
    
    //CONSTRUCTOR
    public GamePanel() 
    {
        initComponents();
        
        setFocusable(true);
        requestFocus();
        //readyForTermination();
        
        addKeyListener(this);
        addMouseListener(this);
        addMouseWheelListener(this);
         
        rando = new java.util.Random();
        
        setBackground(Color.RED);
        setPreferredSize(new Dimension(VIEW_WINDOW_WIDTH,VIEW_WINDOW_HEIGHT));
        
        hexMap = new HexMap(HEX_ROWS,HEX_COLS);
        hexMap.setupMap(BIG_DB_WIDTH,BIG_DB_HEIGHT,100,100,64);
    
        
        selectedHex = null;
        
        currentWindowX = 0;
        currentWindowY = 0;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    
    //*** ADD NOTIFY
    //A mystery
    @Override
    public void addNotify()
    {
        //Creates the peer, starts the game
        super.addNotify();
        startGame();
    }
    
    @Override    
    protected void finalize() throws Throwable
    {
        super.finalize();
        if (animator != null)
        {
            running = false;
        }
    }
   
    //*** START GAME
    private void startGame()
    {
        if ((animator == null) || (running == false))
        {
           animator = new Thread(this);
           animator.start();
        }
    }
    
    
     
    //*** STOP GAME
    public void stopGame()
    {
        running = false;
    }
    
    
    //*** RUN
    //Update, render, sleep
    @Override
    public void run()
    {
        running = true;
        while (running == true)
        {
            gameUpdate();
            gameRender();
            paintScreen();
            
            //Nighty-night
            try
            {
                Thread.sleep(SLEEP_INTERVAL);
            }
            
            catch (InterruptedException ex)
            {
                
            }
        }
        
        System.exit(0);
    }

    
    //*** GAME UPDATE
    private void gameUpdate()
    {
        if (gameOver == false)
        {
            
        }
    }//gameover != true
    
    
    //GAME RENDER
    private void gameRender()
    {
        if (dbImage == null)
        {
            dbImage = createImage(VIEW_WINDOW_WIDTH, VIEW_WINDOW_HEIGHT);
        }
        
        if (dbImage == null)
        {
            System.out.println("ERROR: dbImage is null");
            return;
        }
        
        else
        {
            dbg = dbImage.getGraphics();
        }
        
        Graphics bigMapGraphics = hexMap.getImage().getGraphics();
        BufferedImage temp = hexMap.getImage();
        temp = temp.getSubimage(currentWindowX, currentWindowY, 800, 600);

        dbg.drawImage(temp,0,0,800,600, this);
        
  
        if (scrolling)
        {

            dbg.setColor(Color.RED);
            dbg.drawString("SCROLLING", 10,10);
            dbg.drawString("scrollingX:"+scrollingX, 10, 20);
            dbg.drawString("scrollingY:"+scrollingY, 10, 30);
            dbg.drawString("zoom:" + zoomFactor,10,40);
            
            java.awt.PointerInfo pInfo = java.awt.MouseInfo.getPointerInfo();
            
            //check for horizontal scroll
            //Compare where the mouse was at initial click to where it is now
            //if they're different AND the addition of the difference to the current position of the window
            //does not exeed the max size of the big map MINUS the size of the view window (or is less than zero)
            //apply the difference.
            if ((pInfo.getLocation().x != scrollingX) && 
               ((currentWindowX + pInfo.getLocation().x - scrollingX) >= 0) && 
               ((currentWindowX + pInfo.getLocation().x - scrollingX) <= (BIG_DB_WIDTH - PANEL_WIDTH))) 
            {
                currentWindowX += (pInfo.getLocation().x - scrollingX)/5;
            }
            
            //Same for vertical scroll
            if ((pInfo.getLocation().y != scrollingY) && 
               ((currentWindowY + pInfo.getLocation().y - scrollingY) >= 0) && 
               ((currentWindowY + pInfo.getLocation().y - scrollingY) <= (BIG_DB_HEIGHT - PANEL_HEIGHT))) 
            {
                currentWindowY += (pInfo.getLocation().y - scrollingY)/5;
            }
           
        }
        
        if (gameOver == true)
        {
            gameOverMsg(dbg);
        }
    }
    
    //PAINT COMPONENT
    @Override
    public void paintComponent(Graphics g)
    {
        if (dbImage != null)
        {
           g.drawImage(dbImage, 0, 0, null); 
        }
    }

    
    //PAINT SCREEN
    //active rendering to the screen
    private void paintScreen()
    {
        Graphics g;
        
        try 
        {
            g = this.getGraphics();
            if ((g != null) && (dbImage != null))
            {
                g.drawImage(dbImage, 0, 0, null);
            }
            
            java.awt.Toolkit.getDefaultToolkit().sync();
            
            g.dispose();
        }
        
        catch (Exception e)
        {
            System.out.println("Graphics context error:" + e);
        }
        
        
    }
    
    //GAME OVER MSG
    private void gameOverMsg(Graphics g)
    {
        //g.drawString(msg,x,y);
    }
    
    
    //*** KEYBOARD INPUT ***             
    
    
    public void keyPressed(KeyEvent e)
    {
        switch (e.getKeyChar())
        {
            
            default:
                break;
        }
    }
    
    public void keyReleased(KeyEvent e)
    {
        
    }
    
    public void keyTyped(KeyEvent e)
    {   
        
        switch (e.getKeyChar())
        {
            
            default:
                break;
               
        }       

    }
   
    //*** MOUSE INPUT ***
    
    //MOUSE WHEEL MOVED
    //Zooms in and out
    @Override
    public void mouseWheelMoved(MouseWheelEvent e)
    {
        
        //System.out.println(e.getWheelRotation());
        
        //Scroll DOWN, zoom IN
        if (e.getWheelRotation() >= 0)
        {           
            if ((zoomFactor <= 1) && ((zoomFactor - .10) > 0))
            {
                zoomFactor -= .10;
            }
        }
        
        //Scroll UP, zoom OUT
        else
        {
            if (( (zoomFactor < 1) && (zoomFactor + .10) <= 1))
            {
                zoomFactor += .10;
            }
        }
    }
    
    
    @Override
    public void mouseEntered(MouseEvent e)
    {
        
    }
    
    @Override
    public void mouseExited(MouseEvent e)
    {
        
    }
   
   
    //MOUSE CLICKED
    
    @Override
    public void mouseClicked(MouseEvent e)
    {   
        //*LEFT* CLICK
        if (e.getButton() == MouseEvent.BUTTON1)
        {
            java.awt.Polygon candidate = hexMap.getPolygon(e.getX()+currentWindowX, e.getY()+currentWindowY);
            if (candidate != null)
            {
                Hex thisHex = hexMap.getHexFromPoly(candidate);
                
                if (thisHex != null)
                {
                    if (thisHex.isSelected() == false)
                    {
                        thisHex.select();
                        hexMap.updateMapImage();
                    }
                    else
                    {
                        thisHex.deselect();
                        hexMap.updateMapImage();
                    }    
                }
            }
              
        }//mouse
        
        
        //*RIGHT* CLICK
        if (e.getButton() == MouseEvent.BUTTON3)
        {
            
        }//if RIGHT BUTTON
    }  
   
    @Override
    public void mousePressed(MouseEvent e)
    {
        if (e.getButton() == MouseEvent.BUTTON3)
        {
            scrolling = true;

            java.awt.PointerInfo pInfo = java.awt.MouseInfo.getPointerInfo();
            scrollingX = pInfo.getLocation().x;
            scrollingY = pInfo.getLocation().y;
        }
    }
    
    
    @Override
    public void mouseReleased(MouseEvent e)
    {
        if (e.getButton() == MouseEvent.BUTTON3)
        {
            scrolling = false;
        }
    }
    
    
    
}
