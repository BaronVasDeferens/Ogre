/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ogre;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.image.BufferedImage;
import static java.awt.image.ImageObserver.HEIGHT;
import static java.awt.image.ImageObserver.WIDTH;
import java.io.IOException;
import java.io.InputStream;
import javax.imageio.ImageIO;
import java.util.LinkedList;
import java.util.Enumeration;

/**
 *
 * @author Skot
 */
public class GamePanel extends javax.swing.JPanel implements Runnable, KeyListener, MouseListener, MouseWheelListener {

    //CONSTANTS
    private final int SLEEP_INTERVAL = 10;
    private static final int PANEL_WIDTH = 800;
    private static final int PANEL_HEIGHT = 600;
    //private static final int BLOCK_SIZE = 30; //in pixels
    
    //for the hex map
    public int hexSide = 64;
    
    final int BIG_DB_WIDTH = 2500;
    public final int BIG_DB_HEIGHT = 2000;
    
    //private Graphics bigMapGraphics;
    private Image bigMap;
    
    public final int HEX_ROWS = 21;
    public final int HEX_COLS = 15;
    
    //Hex data
    int [][] gridMap;
    
    public final int VIEW_WINDOW_WIDTH = 800;
    public final int VIEW_WINDOW_HEIGHT = 600;
    
    
    //VARIABLES
    private Thread animator;
    private volatile boolean running = false;    
    private volatile boolean gameOver = false;
    
    private Graphics dbg;
    private Image dbImage = null;
    
    java.util.Random rando;
    
    //BufferedImage picture;
    
    LinkedList<java.awt.Polygon> clickMap;
    java.awt.Polygon selectedHex;
    
    //User-interaction flags
    boolean scrolling = false;
    int scrollingX, scrollingY;     //stores prior position of mouse to compare
    int currentWindowX, currentWindowY;   //stores current position of the upper corner of the view window
    
    
    //CONSTRUCTOR
    public GamePanel() 
    {
        initComponents();
        
        setFocusable(true);
        requestFocus();
        //readyForTermination();
        
        addKeyListener(this);
        addMouseListener(this);
        addMouseWheelListener(this);
         
        rando = new java.util.Random();
        
        setBackground(Color.RED);
        setPreferredSize(new Dimension(VIEW_WINDOW_WIDTH,VIEW_WINDOW_HEIGHT));
        
        clickMap = new LinkedList();
        clickMap.clear();
        
        selectedHex = null;
        
        bigMap = setupHexMap();
        
        currentWindowX = 0;
        currentWindowY = 0;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    
    //*** ADD NOTIFY
    //A mystery
    @Override
    public void addNotify()
    {
        //Creates the peer, starts the game
        super.addNotify();
        startGame();
    }
    
    @Override    
    protected void finalize() throws Throwable
    {
        super.finalize();
        if (animator != null)
        {
            running = false;
        }
    }
   
    //*** START GAME
    private void startGame()
    {
        if ((animator == null) || (running == false))
        {
           animator = new Thread(this);
           animator.start();
        }
    }
    
    
     
    //*** STOP GAME
    public void stopGame()
    {
        running = false;
    }
    
    
    //*** RUN
    //Update, render, sleep
    @Override
    public void run()
    {
        running = true;
        while (running == true)
        {
            gameUpdate();
            gameRender();
            paintScreen();
            
            //Nighty-night
            try
            {
                Thread.sleep(SLEEP_INTERVAL);
            }
            
            catch (InterruptedException ex)
            {
                
            }
        }
        
        System.exit(0);
    }

    
    //*** GAME UPDATE
    private void gameUpdate()
    {
        if (gameOver == false)
        {
            
        }
    }//gameover != true
    
    
    //GAME RENDER
    private void gameRender()
    {
        if (dbImage == null)
        {
            dbImage = createImage(VIEW_WINDOW_WIDTH, VIEW_WINDOW_HEIGHT);
        }
        
        if (dbImage == null)
        {
            System.out.println("ERROR: dbImage is null");
            return;
        }
        
        else
        {
            dbg = dbImage.getGraphics();
        }
        
        Graphics bigMapGraphics;
        
        if (bigMap != null)
        {
            bigMapGraphics = bigMap.getGraphics();
        }
        else
        {
            bigMap = setupHexMap();
        }
        
        //bigMapGraphics.setClip(0,0,PANEL_WIDTH, PANEL_HEIGHT);
        //bigMapGraphics.drawImage(dbImage, PANEL_WIDTH, PANEL_HEIGHT, this);
        
        
        //Clip
        
            BufferedImage temp = (BufferedImage)bigMap;
            temp = temp.getSubimage(currentWindowX, currentWindowY, 800, 600);
            dbg.drawImage(temp,0,0,800,600, this);
        
  
        if (scrolling)
        {

            dbg.setColor(Color.RED);
            dbg.drawString("SCROLLING", 10,10);
            //dbg.drawString("viewWindowX:"+viewWindowX, 10, 20);
            //dbg.drawString("viewWindowY:"+viewWindowY, 10, 30);
            
            


            dbg.drawString("scrollingX:"+scrollingX, 10, 20);
            dbg.drawString("scrollingY:"+scrollingY, 10, 30);
            
            java.awt.PointerInfo pInfo = java.awt.MouseInfo.getPointerInfo();
            
            //check for horizontal scroll
            //Compare where the mouse was at initial click to where it is now
            //if they're different AND the addition of the difference to the current position of the window
            //does not exeed the max size of the big map MINUS the size of the view window (or is less than zero)
            //apply the difference.
            if ((pInfo.getLocation().x != scrollingX) && 
               ((currentWindowX + pInfo.getLocation().x - scrollingX) >= 0) && 
               ((currentWindowX + pInfo.getLocation().x - scrollingX) <= (BIG_DB_WIDTH - PANEL_WIDTH))) 
            {
                currentWindowX += (pInfo.getLocation().x - scrollingX)/5;
            }
            
            //Same for vertical scroll
            if ((pInfo.getLocation().y != scrollingY) && 
               ((currentWindowY + pInfo.getLocation().y - scrollingY) >= 0) && 
               ((currentWindowY + pInfo.getLocation().y - scrollingY) <= (BIG_DB_HEIGHT - PANEL_HEIGHT))) 
            {
                currentWindowY += (pInfo.getLocation().y - scrollingY)/5;
            }
           
        }
 
        
        //Highlight a hex
        if(selectedHex != null)
        {
            dbg.setColor(Color.RED);
            dbg.fillPolygon(selectedHex);
            dbg.drawPolygon(selectedHex);
        }
        
        //Draw 
        
        //DRAW 
        if (gameOver == true)
        {
            gameOverMsg(dbg);
        }
    }
    
    //PAINT COMPONENT
    @Override
    public void paintComponent(Graphics g)
    {
        if (dbImage != null)
        {
           g.drawImage(dbImage, 0, 0, null); 
        }
    }

    
    //PAINT SCREEN
    //active rendering to the screen
    private void paintScreen()
    {
        Graphics g;
        
        try 
        {
            g = this.getGraphics();
            if ((g != null) && (dbImage != null))
            {
                g.drawImage(dbImage, 0, 0, null);
            }
            
            java.awt.Toolkit.getDefaultToolkit().sync();
            
            g.dispose();
        }
        
        catch (Exception e)
        {
            System.out.println("Graphics context error:" + e);
        }
        
        
    }
    
    //GAME OVER MSG
    private void gameOverMsg(Graphics g)
    {
        //g.drawString(msg,x,y);
    }
    
    
    //*** KEYBOARD INPUT ***             
    
    
    public void keyPressed(KeyEvent e)
    {
        switch (e.getKeyChar())
        {
            
            default:
                break;
        }
    }
    
    public void keyReleased(KeyEvent e)
    {
        
    }
    
    public void keyTyped(KeyEvent e)
    {   
        
        switch (e.getKeyChar())
        {
            
            default:
                break;
               
        }       

    }
   
    //*** MOUSE INPUT ***
    
    //MOUSE WHEEL MOVED
    //Zooms in and out
    @Override
    public void mouseWheelMoved(MouseWheelEvent e)
    {
        
        //System.out.println(e.getWheelRotation());
        
        //Scroll DOWN, zoom IN
        if (e.getWheelRotation() >= 0)
        {           

            //disabled for now
//            switch (hexSide)
//            {
//                case 52:
//                    hexSide = 64;
//                    clickMap.clear();
//                    break;
//                case 44:
//                    hexSide = 52;
//                    clickMap.clear();
//                    break;
//                case 36:
//                    hexSide = 44;
//                    clickMap.clear();
//                    break;
//                case 34:
//                    hexSide = 36;
//                    clickMap.clear();
//                    break;
//                case 28:
//                    hexSide = 34;
//                    clickMap.clear();
//                    break;
//                case 20:
//                    hexSide = 28;
//                    clickMap.clear();
//                    break;
//                default:
//                    break;
//            }
                    
        }
        
        //Scroll UP, zoom OUT
        else
        {
            //disable for now
//            switch (hexSide)
//            {
//               case 64:
//                   hexSide = 52;
//                   clickMap.clear();
//                   break;
//               case 52:
//                    hexSide = 44;
//                    clickMap.clear();
//                    break;
//                case 44:
//                    hexSide = 36;
//                    clickMap.clear();
//                    break;
//                case 36:
//                    hexSide = 34;
//                    clickMap.clear();
//                    break;
//                case 34:
//                    hexSide = 28;
//                    clickMap.clear();
//                    break;
//                case 28:
//                     hexSide = 20;
//                     clickMap.clear();
//                    break;
//                case 20:
//                default:
//                    break;
//            }

        }
    }
    
    
    @Override
    public void mouseEntered(MouseEvent e)
    {
        
    }
    
    @Override
    public void mouseExited(MouseEvent e)
    {
        
    }
   
   
    //MOUSE CLICKED
    
    @Override
    public void mouseClicked(MouseEvent e)
    {   
        //*LEFT* CLICK
        if (e.getButton() == MouseEvent.BUTTON1)
        {
            
        }//mouse
        
        
        //*RIGHT* CLICK
        if (e.getButton() == MouseEvent.BUTTON3)
        {
            
        }//if RIGHT BUTTON
    }  
   
    @Override
    public void mousePressed(MouseEvent e)
    {
        scrolling = true;
        
        java.awt.PointerInfo pInfo = java.awt.MouseInfo.getPointerInfo();
        scrollingX = pInfo.getLocation().x;
        scrollingY = pInfo.getLocation().y;
    }
    
    
    @Override
    public void mouseReleased(MouseEvent e)
    {
        scrolling = false;
    }
    
    //SETUP HEX MAP
    //Creates the big 2352x1680 dbImage
    private BufferedImage setupHexMap()
    {
        
        Image bigMapImage = createImage(BIG_DB_WIDTH, BIG_DB_HEIGHT);
        
        
        if (bigMapImage == null)
        {
            //System.out.println("ERROR: bigMapImage is null");
            return (null);
        }
        
        Graphics bigMapGraphics = bigMapImage.getGraphics();
        
        //Clear background
        bigMapGraphics.setColor(java.awt.Color.WHITE);
        bigMapGraphics.fillRect(0,0,BIG_DB_WIDTH,BIG_DB_HEIGHT);
       
        int x_origin = 100;
        int y_origin = 100;
        int x = x_origin;
        int y = y_origin;

        //Draw hex field
        for (int i = 1; i < HEX_ROWS+1; i++)
        {
           for (int j = 1; j < HEX_COLS+1; j++)
           {
               java.awt.Polygon p = new java.awt.Polygon();
               p.reset();
               
               p.addPoint(x +(hexSide/2), y);
               p.addPoint(x+(hexSide/2) + hexSide, y);
               p.addPoint(x + 2*hexSide, (int)(.8660* hexSide + y));
               p.addPoint(x+(hexSide/2) + hexSide, (int)(.8660 * 2 * hexSide + y));
               p.addPoint(x+(hexSide/2),(int)(.8660*2*hexSide + y));
               p.addPoint(x,y+(int)(.8660 * hexSide));
               
               bigMapGraphics.setColor(Color.BLACK);
               //dbg.setColor(new Color(rando.nextInt(255),rando.nextInt(255),rando.nextInt(255)));
               bigMapGraphics.drawPolygon(p);
               //clickMap.add(p);
               
               y = y + (int)(2 * .8660 * hexSide);
           }
        
            x = x + (hexSide/2) + hexSide;
            
            if ((i%2) > 0)
               y = y_origin + (int)(.8660 * hexSide); 
            else
                y = y_origin;
            
        }    
        
        return (BufferedImage)(bigMapImage);
        
    }
     
    
    
}
